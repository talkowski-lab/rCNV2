#!/usr/bin/env Rscript

######################
#    rCNV Project    #
######################

# Copyright (c) 2021-Present Ryan L. Collins and the Talkowski Laboratory
# Distributed under terms of the MIT License (see LICENSE)
# Contact: Ryan L. Collins <rlcollins@g.harvard.edu>

# Plotting functions used for gene scoring analyses


#' Plot gene feature distribution vs. scores
#'
#' Swarmplots of distributions for a single gene feature per gene score category
#'
#' @param feats matrix of gene features
#' @param ds.groups list of genes split by score category as generated by [classify.genes.by.score()]
#' @param feat.idx column index of feature to be plotted \[default: 2\]
#' @param title title for plot \[default: NULL\]
#' @param swarm.max maximum number of points for a swarmplot before rendering as a violin \[default: 5000\]
#' @param max.ylim maximum Y axis value \[default: 6\]
#' @param blue.bg add light blue background shading \[default: FALSE\]
#' @param parmar plotting margins passed to `par(mar=...)`
#'
#' @seealso [load.scores()], [classify.genes.by.score()]
#'
#' @export plot.feature.bydsgroup
#' @export
plot.feature.bydsgroup <- function(feats, ds.groups, feat.idx=2, title=NULL,
                                   swarm.max=5000, max.ylim=6, blue.bg=FALSE,
                                   parmar=c(2.25, 2.75, 1.25, 0.5)){
  # Get plot values
  vals <- lapply(ds.groups, function(genes){
    as.numeric(feats[which(feats$gene %in% genes), feat.idx])
  })
  names(vals) <- names(ds.groups)
  vals <- list("hi.hc"=vals$hi.hc, "ds.hc"=vals$ds.hc, "ts.hc"=vals$ts.hc,
               "hi.lc"=vals$hi.lc, "ds.lc"=vals$ds.lc, "ts.lc"=vals$ts.lc,
               "ns"=vals$ns)
  ylims <- range(unlist(vals), na.rm=T)
  if(ylims[1] < -max.ylim){ylims[1] <- -max.ylim}
  if(ylims[2] > max.ylim){ylims[2] <- max.ylim}
  x.at <- c(1:3, 5:7, 9)-0.5
  plot.colors <- c(cnv.colors[c(1, 3, 2)], control.cnv.colors[c(1, 3, 2)], ns.color)
  border.colors <- c(cnv.blacks[c(1, 3, 2)], cnv.colors[c(1, 3, 2)], "gray30")
  black.colors <- c(rep(cnv.blacks[c(1, 3, 2)], 2), "gray30")
  lab.colors <- c(plot.colors[1:3], plot.colors[1:3], "black")
  pt.cex <- c(rep(0.12, 3), rep(0.075, 4))
  if(is.null(title)){
    title <- colnames(feats)[feat.idx]
  }
  if(blue.bg==TRUE){
    plot.bg <- bluewhite
    plot.border <- NA
    plot.bty <- "n"
    grid.col <- "white"
  }else{
    plot.bg <- "white"
    plot.border <- NA
    plot.bty <- "n"
    grid.col <- NA
  }

  # Prep plot area
  par(mar=parmar, bty="n")
  plot(NA, xlim=c(0, 9), ylim=ylims,
       xaxt="n", xlab="", yaxt="n", ylab="")
  rect(xleft=par("usr")[1], xright=par("usr")[2],
       ybottom=par("usr")[3], ytop=par("usr")[4],
       bty=plot.bty, border=plot.border, col=plot.bg)
  y.ax.at <- sort(unique(round(axTicks(2))))
  if(length(y.ax.at) > 6){
    y.ax.at <- y.ax.at[seq(1, length(y.ax.at), 2)]
  }
  abline(h=0, col=blueblack, lty=5)

  # Add axes
  x.labs <- c(rep(c("HI", "DS", "TS"), 2), "NS")
  sapply(1:7, function(i){
    axis(1, at=x.at[i], tick=F, line=-0.9,
         labels=x.labs[i], col.axis=lab.colors[i])
  })
  axis(1, at=c(0.1, 2.9), tck=0, col=blueblack, labels=NA, line=1.1)
  axis(1, at=c(4.1, 6.9), tck=0, col=blueblack, labels=NA, line=1.1)
  axis(1, at=c(8.1, 8.9), tck=0, col=blueblack, labels=NA, line=1.1)
  axis(1, at=1.5, line=0.1, labels=bquote("Score" >= 0.9), tick=F)
  axis(1, at=5.5, line=0.1, labels="0.5-0.9", tick=F)
  axis(1, at=8.5, line=0.1, labels=bquote("" < 0.5), tick=F)
  axis(2, at=c(-10e10, 10e10), tck=0, col=blueblack)
  axis(2, at=y.ax.at, tck=-0.03, labels=NA, col=blueblack)
  axis(2, at=y.ax.at, tick=F, las=2, line=-0.65)
  mtext(2, text="Feature Value (Z-Score)", line=1.7)
  mtext(3, text=title)

  # Add values
  sapply(1:7, function(i){
    ivals <- vals[[i]][which(!is.na(vals[[i]]))]
    if(length(unique(ivals)) > 2){
      if(length(ivals) <= swarm.max){
        beeswarm(ivals, at=x.at[i], col=plot.colors[i], cex=pt.cex[i], add=T,
                 corral="wrap", corralWidth=0.8)
      }else{
        vioplot(ivals, at=x.at[i], col=plot.colors[i], border=border.colors[i],
                add=T, drawRect=F, h=0.1)
      }
      vmed <- median(ivals)
      segments(x0=x.at[i]+0.2, x1=x.at[i]-0.2, y0=vmed, y1=vmed,
               lend="round", col=black.colors[i], lwd=2)
    }
  })
}


#' Barplot inset for score performance
#'
#' Superimposed barplot of one statistic per category from [evaluate.scores()]
#'
#' @param values values to be plotted
#' @param colors colors for each bar
#' @param xleft leftmost position of inset on X axis
#' @param xright rightmost position of inset on X axis
#' @param ybottom bottommost position of inset on Y axis
#' @param ytop topmost position of inset on Y axis
#' @param min.value minimum value to plot
#' @param max.value maximum value to plot
#' @param title title of plot
#' @param add.labels boolean indicator whether to label bars \[default: TRUE\]
#' @param lab.cex cex value for bar labels \[default: 0.6\]
#' @param lab.colors colors for bar labels
#' @param buffer relative buffer between bars
#'
#' @seealso [evaluate.score()]
#'
#' @export superimposed.barplot
#' @export
superimposed.barplot <- function(values, colors, xleft, xright, ybottom, ytop,
                                 min.value=NULL, max.value=NULL, title=NULL,
                                 add.labels=TRUE, lab.cex=0.6, lab.colors=NULL,
                                 buffer=0.025){
  # Ã…dd subpanel
  rect(xleft=xleft+buffer, xright=xright-buffer, ybottom=ybottom+buffer, ytop=ytop-buffer,
       col=bluewhite, border=blueblack)
  text(x=mean(c(xleft, xright)), y=ytop-(2*buffer), labels=title, pos=3)

  # Set parameters & get plot values
  inner.xleft <- xleft + (2*buffer)
  inner.xright <- xright - (2*buffer)
  inner.ybottom <- ybottom + (2*buffer)
  inner.ytop <- ytop - (2*buffer)
  n.bars <- length(values)
  bar.buffer <- 0.1
  bar.height <- (inner.ytop - inner.ybottom) / (n.bars + 1)
  bar.y.breaks <- seq(inner.ybottom, inner.ytop, length.out=n.bars + 1)
  bar.ybottom <- bar.y.breaks[1:n.bars] + (bar.buffer * bar.height)
  bar.ytop <- bar.y.breaks[2:(n.bars+1)] - (bar.buffer * bar.height)
  max.bar.length <- inner.xright - inner.xleft
  bar.mid <- mean(c(inner.xright, inner.xleft))
  centered.values <- values - min.value
  norm.values <- centered.values * (max.value / (max.value - min.value))
  scaled.values <- norm.values * max.bar.length
  bar.xleft <- rep(inner.xleft, times=n.bars)
  bar.xright <- inner.xleft + scaled.values

  # Add background gridlines
  gridlines.x.at <- seq(inner.xleft, inner.xright, length.out=6)
  segments(x0=gridlines.x.at, x1=gridlines.x.at,
           y0=inner.ybottom, y1=inner.ytop,
           col="white")

  # Add bars & labels
  rect(xleft=bar.xleft, xright=bar.xright, ybottom=bar.ybottom, ytop=bar.ytop, border=NA, col=colors)
  if(is.null(lab.colors)){
    lab.colors <- rep("black", n.bars)
    lab.colors[1:ceiling(n.bars/2)] <- "white"
  }
  lab.pos <- sapply(norm.values, function(x){if(x>=0.5){2}else{4}})
  if(any(lab.pos==4)){
    lab.colors[which(lab.pos==4)] <- "black"
  }
  lab.x.adj <- sapply(norm.values, function(x){if(x>=0.5){2*buffer}else{-2*buffer}})
  lab.y.at <- (bar.y.breaks[1:n.bars]+bar.y.breaks[-1])/2
  text(x=bar.xright+lab.x.adj, y=lab.y.at - (bar.buffer * bar.height), pos=lab.pos,
       col=lab.colors, labels=round(values, 3), cex=lab.cex)

  # Add cleanup line
  segments(x0=inner.xleft, x1=inner.xleft, y0=inner.ybottom, y1=inner.ytop, col=blueblack)
}


#' Plot ROC curve
#'
#' Plot receiver operating characteristic curves from a list of [evaluate.score()] outputs
#'
#' @param data list of outputs from [evaluate.score()]
#' @param colors colors for each entry in `data` \[default: use viridis()\]
#' @param nested.auc boolean indicator to add nested AUC barplot \[default: TRUE\]
#' @param auc.text.colors colors for labels in nested AUC barplot
#' @param grid.col color of gridlines for plot \[default: very light blue\]
#' @param diag.col color of diagonal line \[default: very light blue\]
#' @param ax.tick `tck` value for X and Y axes \[default: -0.025]
#' @param parmar values passed to `par(mar=...)`
#'
#' @export plot.roc
#' @export
plot.roc <- function(data, colors=NULL, nested.auc=TRUE, auc.text.colors=NULL,
                     grid.col=bluewhite, diag.col=bluewhite,
                     ax.tick=-0.025, parmar=c(2.5, 2.5, 0.75, 0.75)){
  # Get plot data
  if(is.null(colors)){
    colors <- rev(viridis(length(data)))
  }

  # Prep plot area
  par(mar=parmar, bty="n")
  plot(NA, xlim=c(0, 1), ylim=c(0, 1), type="n",
       xaxt="n", yaxt="n", xaxs="i", yaxs="i", xlab="", ylab="")
  rect(xleft=par("usr")[1], xright=par("usr")[2],
       ybottom=par("usr")[3], ytop=par("usr")[4],
       border=NA, bty="n", col="white")
  abline(h=axTicks(2), v=axTicks(1), col=grid.col)
  abline(0, 1, col=diag.col, lwd=2, lty=5)
  box(col=bluewhite, bty="o", xpd=T)

  # Add curves
  lorder <- order(-sapply(data, function(x){x$roc.auc}))
  sapply(rev(lorder), function(i){
    x <- data[[i]]
    points(x$roc$frac_false, x$roc$frac_true,
           type="l", lwd=3, col=colors[i], xpd=T)
  })

  # Add nested AUC subpanel
  if(nested.auc==TRUE){
    superimposed.barplot(rev(sapply(data, function(l){l$roc.auc})), rev(colors),
                         xleft=0.5, xright=1, ybottom=0, ytop=0.5,
                         min.value=0, max.value=1, title="AUC",
                         lab.colors=auc.text.colors, buffer=0.02)
  }

  # Add axes
  axis(1, labels=NA, col=blueblack, tck=ax.tick)
  axis(1, tick=F, line=-0.6)
  mtext(1, line=1.25, text="False positive rate")
  axis(2, labels=NA, col=blueblack, tck=ax.tick)
  axis(2, tick=F, line=-0.6, las=2)
  mtext(2, line=1.65, text="True positive rate")
}


#' Plot precision-recall curve
#'
#' Plot precision-recall curves from a list of [evaluate.score()] outputs
#'
#' @param data list of outputs from [evaluate.score()]
#' @param colors colors for each entry in `data` \[default: use viridis()\]
#' @param nested.auc boolean indicator to add nested AUC barplot \[default: TRUE\]
#' @param auc.text.colors colors for labels in nested AUC barplot
#' @param grid.col color of gridlines for plot \[default: very light blue\]
#' @param ax.tick `tck` value for X and Y axes \[default: -0.025]
#' @param parmar values passed to `par(mar=...)`
#'
#' @export plot.prc
#' @export
plot.prc <- function(data, colors=NULL, nested.auc=TRUE, auc.text.colors=NULL,
                     grid.col=bluewhite, ax.tick=-0.025,
                     parmar=c(2.5, 2.5, 0.75, 0.75)){
  # Get plot data
  if(is.null(colors)){
    colors <- rev(viridis(length(data)))
  }

  # Prep plot area
  par(mar=parmar, bty="n")
  plot(NA, xlim=c(0, 1), ylim=c(0, 1), type="n",
       xaxt="n", yaxt="n", xaxs="i", yaxs="i", xlab="", ylab="")
  rect(xleft=par("usr")[1], xright=par("usr")[2],
       ybottom=par("usr")[3], ytop=par("usr")[4],
       border=NA, bty="n", col="white")
  abline(h=axTicks(2), v=axTicks(1), col=grid.col)
  box(col=bluewhite, bty="o", xpd=T)

  # Add curves
  lorder <- order(-sapply(data, function(x){x$prc.auc}))
  sapply(rev(lorder), function(i){
    x <- data[[i]]
    points(x$prc$recall, x$prc$precision,
           type="l", lwd=4, col=colors[i], xpd=T)
  })

  # Add nested AUC subpanel
  if(nested.auc==TRUE){
    superimposed.barplot(rev(sapply(data, function(l){l$prc.auc})), rev(colors),
                         xleft=0, xright=0.5, ybottom=0, ytop=0.5,
                         min.value=0, max.value=1, title="AUC",
                         lab.colors=auc.text.colors, buffer=0.02)
  }

  # Add axes & cleanup
  axis(1, labels=NA, col=blueblack, tck=ax.tick)
  axis(1, tick=F, line=-0.6)
  mtext(1, line=1.25, text="Precision")
  axis(2, labels=NA, col=blueblack, tck=ax.tick)
  axis(2, tick=F, line=-0.6, las=2)
  mtext(2, line=1.65, text="Recall")
}


#' Plot simple legend
#'
#' Plot simple color legend
#'
#' @param labels vector of legend labels
#' @param colors vector of legend colors
#'
#' @export simple.legend
#' @export
simple.legend <- function(labels, colors){
  par(mar=rep(0.25, 4), bty="n")
  plot(NA, xlim=c(0, 1), ylim=c(0, length(labels)),
       xaxt="n", yaxt="n", xlab="", ylab="", xaxs="i", yaxs="i")
  points(x=rep(0.1, length(labels)), y=(1:length(labels))-0.5, pch=22,
         col=blueblack, bg=colors, cex=1.8)
  text(x=rep(0.1, length(labels)), y=(1:length(labels))-0.58, pos=4, labels=labels, xpd=T)
}


#' Plot metric stratified by gene scores
#'
#' Plot a metric stratified by CNV type and low/high pHaplo & pTriplo
#'
#' @param strat.dat list of values stratified as desired
#' @param ylims limits for Y axis
#' @param y.title title of Y axis
#' @param parmar values passed to `par(mar=...)`
#'
#' @export plot.stratified.metric
#' @export
plot.stratified.metric <- function(strat.dat, ylims=NULL, y.title=NULL,
                                   parmar=c(1, 3, 0.5, 0.5)){
  # Get plot data
  if(is.null(ylims)){
    ylims.init <- range(as.numeric(sapply(strat.dat, function(df){df[, 1]})), na.rm=T)
    ylims.buffer <- (1/3)*diff(ylims.init)
    ylims <- c(ylims.init[1]-ylims.buffer, ylims.init[2]+ylims.buffer)
  }
  y0.val <- min(ylims)
  strat.dat <- lapply(strat.dat, function(df){
    df[which(df<ylims[1])] <- ylims[1]
    return(df)
  })
  y.bottom.buffer <- 0.25*diff(ylims)
  y.rect.tops <- y0.val - (c(0.015, 0.14) * diff(ylims))
  y.rect.bottoms <- y0.val - (c(0.11, 0.235) * diff(ylims))
  ylims <- c(ylims[1]-y.bottom.buffer, ylims[2])
  x.left.border <- (0:3)+0.15
  x.right.border <- (1:4)-0.15
  del.x.at <- (1:4)-0.5-0.15
  dup.x.at <- (1:4)-0.5+0.15

  # Prep plot area
  par(bty="n", mar=parmar)
  plot(NA, xlim=c(0, 4), ylim=ylims,
       xaxt="n", yaxt="n", xlab="", ylab="", xaxs="i", yaxs="i")
  rect(xleft=x.left.border, xright=x.right.border,
       ybottom=min(ylims), ytop=max(ylims),
       xpd=T, border=NA, bty="n", col=bluewhite)

  # Add lower x-axis annotation
  axis(2, at=((y.rect.tops+y.rect.bottoms)/2)[1], tick=F, las=2, labels="pHaplo", line=-1.25)
  axis(2, at=((y.rect.tops+y.rect.bottoms)/2)[2], tick=F, las=2, labels="pTriplo", line=-1.25)
  rect(xleft=x.left.border+0.1, xright=x.right.border-0.1,
       ytop=c(rep(y.rect.tops[1], 4), rep(y.rect.tops[2], 4)),
       ybottom=c(rep(y.rect.bottoms[1], 4), rep(y.rect.bottoms[2], 4)),
       bty="n", border=NA,
       col=c(ns.color, cnv.colors[1], ns.color, cnv.colors[1],
             ns.color, ns.color, cnv.colors[2], cnv.colors[2]))
  text(x=0.5:3.5, y=((y.rect.tops+y.rect.bottoms)/2)[1],
       labels=c("Low", "High", "Low", "High"),
       col=c("gray30", "white", "gray30", "white"),
       cex=0.85)
  text(x=0.5:3.5, y=((y.rect.tops+y.rect.bottoms)/2)[2],
       labels=c("Low", "Low", "High", "High"),
       col=c("gray30", "gray30", "white", "white"),
       cex=0.85)
  axis(1, at=par("usr")[1:2], line=0, tck=0, col=bluewhite)
  sapply(1:4, function(i){
    axis(1, at=c(x.left.border[i], x.right.border[i]), tck=0, col=blueblack,
         line=0, labels=NA)
  })
  axis(1, at=0.5:3.5, tick=F, line=-0.9, labels=c("NS", "HI", "TS", "DS"))

  # Add points & CI bars
  segments(x0=del.x.at, x1=del.x.at, y0=strat.dat[[1]][, 2], y1=strat.dat[[1]][, 3],
           col=cnv.colors[1], lend="round", lwd=2)
  segments(x0=dup.x.at, x1=dup.x.at, y0=strat.dat[[2]][, 2], y1=strat.dat[[2]][, 3],
           col=cnv.colors[2], lend="round", lwd=2)
  points(x=del.x.at, y=strat.dat[[1]][, 1], pch=19, col=cnv.colors[1])
  points(x=dup.x.at, y=strat.dat[[2]][, 1], pch=19, col=cnv.colors[2])

  # Add cleanup bar to X axis
  abline(h=y0.val, col=blueblack)

  # Add y axis
  y.ax.at <- axTicks(2)[which(axTicks(2) >= y0.val)]
  axis(2, at=c(y0.val, 10e10), tck=0, labels=NA, col=blueblack)
  axis(2, at=y.ax.at, tck=-0.025, labels=NA, col=blueblack)
  axis(2, at=y.ax.at, las=2, line=-0.65, tick=F)
  axis(2, at=mean(c(y0.val, par("usr")[4])), labels=parse(text=y.title),
       line=0.8, tck=F)
}


