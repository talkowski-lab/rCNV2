#!/usr/bin/env Rscript

######################
#    rCNV Project    #
######################

# Copyright (c) 2021-Present Ryan L. Collins and the Talkowski Laboratory
# Distributed under terms of the MIT License (see LICENSE)
# Contact: Ryan L. Collins <rlcollins@g.harvard.edu>

# Utility functions used for gene scoring analyses


#' Load gene scores
#'
#' Load a dataframe of all gene scores
#'
#' @param scores.in path to gene scores .tsv
#'
#' @return data.frame
#'
#' @export
load.scores <- function(scores.in){
  scores <- read.table(scores.in, header=T, sep="\t", comment.char="", check.names=F)
  colnames(scores) <- c("gene", "pHaplo", "pTriplo")
  scores[, -1] <- apply(scores[, -1], 2, as.numeric)
  return(scores)
}


#' Load gene metadata
#'
#' Load gene metadata from a BED file
#'
#' @param cov.in path to gene metadata
#'
#' @return data.frame
#'
#' @export
load.gene.metadata <- function(cov.in){
  cov <- read.table(cov.in, header=T, sep="\t", comment.char="")[, -c(1:3)]
  cov[, -1] <- apply(cov[, -1], 2, as.numeric)
  return(cov)
}


#' Load gene feature category metadata
#'
#' Load gene feature category metadata from .tsv
#'
#' @param meta.in path to metadata .tsv
#'
#' @return data.frame
#'
#' @export
load.gene.feature.metadata <- function(meta.in){
  feat.meta <- read.table(meta.in, header=T, sep="\t", comment.char="")
  colnames(feat.meta)[1] <- gsub("X.", "", colnames(feat.meta)[1], fixed=T)
  return(feat.meta)
}


#' Load gene score cutoffs
#'
#' Load gene score cutoffs from a .tsv into global environment
#'
#' @param score.cutoffs.in path to input .tsv with score cutoffs
#' @param default.hc.cutoff default high-confidence cutoff \[default: 0.9\]
#' @param default.lc.cutoff default low-confidence cutoff \[default: 0.5\]
#'
#' @details expects a .tsv as generated by empirical_score_cutoffs.R.
#' If `score.cutoffs.in` is `NULL`, will load default cutoffs.
#'
#' @export load.score.cutoffs
#' @export
load.score.cutoffs <- function(score.cutoffs.in, default.hc.cutoff=0.9,
                               default.lc.cutoff=0.5){
  if(is.null(score.cutoffs.in)){
    x <- data.frame("score"=rep(c("pHaplo", "pTriplo"), 2),
                    "confidence"=c("hc", "hc", "lc", "lc"),
                    "cutoff"=c(rep(default.hc.cutoff, 2),
                               rep(default.lc.cutoff, 2)))
  }else{
    x <- read.table(score.cutoffs.in, header=T, sep="\t", comment.char="", check.names=F)
    colnames(x)[1] <- gsub("#", "", colnames(x)[1], fixed=T)
  }
  for(conf in c("hc", "lc")){
    assign(paste("hi", conf, sep="."),
           x$cutoff[which(x$score=="pHaplo" & x$confidence==conf)],
           envir=.GlobalEnv)
    assign(paste("ts", conf, sep="."),
           x$cutoff[which(x$score=="pTriplo" & x$confidence==conf)],
           envir=.GlobalEnv)
  }
}


#' Partition genes by dosage sensitivity
#'
#' Partition genes into subgroups based on dosage sensitivity scores
#'
#' @param scores data.frame of gene scores as loaded by [load.scores()]
#' @param hi.hc minimum score for high-confidence haploinsufficient genes \[default: 0.9\]
#' @param hi.lc minimum score for low-confidence haploinsufficient genes \[default: 0.5\]
#' @param ts.hc minimum score for high-confidence triplosensitive genes \[default: 0.9\]
#' @param ts.lc minimum score for low-confidence triplosensitive genes \[default: 0.5\]
#'
#' @return list of gene symbols for each group
#'
#' @seealso [load.scores()]
#'
#' @export classify.genes.by.score
#' @export
classify.genes.by.score <- function(scores, hi.hc=0.9, hi.lc=0.5, ts.hc=0.9, ts.lc=0.5){
  ds.hc.genes <- scores$gene[which(scores$pHaplo>=hi.hc & scores$pTriplo>=ts.hc)]
  ds.lc.genes <- scores$gene[which(scores$pHaplo>=hi.lc & scores$pTriplo>=ts.lc
                                   & !(scores$gene %in% ds.hc.genes))]
  hi.hc.genes <- scores$gene[which(scores$pHaplo>=hi.hc & scores$pTriplo<ts.lc)]
  hi.lc.genes <- scores$gene[which(scores$pHaplo>=hi.lc & scores$pTriplo<ts.lc
                                   & !(scores$gene %in% hi.hc.genes))]
  ts.hc.genes <- scores$gene[which(scores$pHaplo<hi.lc & scores$pTriplo>=ts.hc)]
  ts.lc.genes <- scores$gene[which(scores$pHaplo<hi.lc & scores$pTriplo>=ts.lc
                                   & !(scores$gene %in% ts.hc.genes))]
  ns.genes <- scores$gene[which(scores$pHaplo<hi.lc & scores$pTriplo<ts.lc)]
  list("ds.hc" = ds.hc.genes, "ds.lc" = ds.lc.genes,
       "hi.hc" = hi.hc.genes, "hi.lc" = hi.lc.genes,
       "ts.hc" = ts.hc.genes, "ts.lc" = ts.lc.genes,
       "ns" = ns.genes)
}


#' Color gene by dosage sensitivity
#'
#' Get gene color based on membership in a given dosage sensitivity subset
#'
#' @param gene gene symbol to evaluate
#' @param ds.groups categories of high- and low-confidence genes as generated by [classify.genes.by.score()]
#'
#' @return color
#'
#' @seealso [classify.genes.by.score()]
#'
#' @export get.gene.color.byscore
#' @export
get.gene.color.byscore <- function(gene, ds.groups){
  if(gene %in% ds.groups$ds.hc){
    cnv.colors[3]
  }else if(gene %in% ds.groups$ds.lc){
    control.cnv.colors[3]
  }else if(gene %in% ds.groups$hi.hc){
    cnv.colors[1]
  }else if(gene %in% ds.groups$hi.lc){
    control.cnv.colors[1]
  }else if(gene %in% ds.groups$ts.hc){
    cnv.colors[2]
  }else if(gene %in% ds.groups$ts.lc){
    control.cnv.colors[2]
  }else{
    ns.color
  }
}


#' Compute gene score ROC
#'
#' Compute receiver operating characteristic of a single score vs. predefined true/false genes
#'
#' @param stats data.frame of scores for all genes
#' @param score score to evaluate; must be a column of `stats`
#' @param true.genes vector of gene symbols to consider true positives
#' @param false.genes vector of gene symbols to consider true negatives
#' @param steps numeric vector of score cutoffs to evaluate \[default: from 1 to 0 in steps of 0.001\]
#'
#' @return data.frame of ROC statistics at each score cutoff
#'
#' @export
roc <- function(stats, score, true.genes, false.genes, steps=seq(1, 0, -0.001)){
  x <- data.frame("score" = stats[, which(colnames(stats) == score)],
                  "true" = stats$gene %in% true.genes,
                  "false" = stats$gene %in% false.genes)
  roc_res <- as.data.frame(t(sapply(steps, function(k){
    idxs <- which(x$score >= k)
    ftrue <- length(which(x$true[idxs])) / length(which(x$true))
    ffalse <- length(which(x$false[idxs])) / length(which(x$false))
    fother <- length(which(!x$true[idxs])) / length(which(!x$true))
    fall <- length(idxs) / nrow(x)
    return(c(k, fall, fother, ftrue, ffalse))
  })))
  roc_res <- rbind(c(-Inf, 0, 0, 0, 0),
                   roc_res,
                   c(Inf, 1, 1, 1, 1))
  colnames(roc_res) <- c("min_score", "frac_all", "frac_other", "frac_true", "frac_false")
  return(roc_res)
}

#' Compute gene score precision-recall statistics
#'
#' Compute precision-recall of a single score vs. predefined true/false genes
#'
#' @param stats data.frame of scores for all genes
#' @param score score to evaluate; must be a column of `stats`
#' @param true.genes vector of gene symbols to consider true positives
#' @param false.genes vector of gene symbols to consider true negatives
#' @param steps numeric vector of score cutoffs to evaluate \[default: from 1 to 0 in steps of 0.001\]
#'
#' @return data.frame of P-R statistics at each score cutoff
#'
#' @export
prc <- function(stats, score, true.genes, false.genes, steps=seq(1, 0, -0.001)){
  x <- data.frame("score" = stats[, which(colnames(stats) == score)],
                  "true" = stats$gene %in% true.genes,
                  "false" = stats$gene %in% false.genes)
  prc_res <- as.data.frame(t(sapply(steps, function(k){
    idxs <- which(x$score >= k)
    prec <- length(which(x$true[idxs])) / (length(which(x$true[idxs])) + length(which(x$false[idxs])))
    recall <- length(which(x$true[idxs])) / length(which(x$true))
    fall <- length(idxs) / nrow(x)
    return(c(k, fall, prec, recall))
  })))
  prc_res <- rbind(c(-Inf, 0, 1, 0),
                   prc_res)
  colnames(prc_res) <- c("min_score", "frac_all", "precision", "recall")
  return(prc_res)
}

#' Evaluate performance of a single gene score
#'
#' Wrapper function to calculate all performance stats a single score
#'
#' @param stats data.frame of scores for all genes
#' @param score score to evaluate; must be a column of `stats`
#' @param true.genes vector of gene symbols to consider true positives
#' @param false.genes vector of gene symbols to consider true negatives
#'
#' @return list of ROC and P-R statistics
#'
#' @seealso [roc()], [prc()]
#'
#' @export
evaluate.score <- function(stats, score, true.genes, false.genes){
  roc.res <- roc(stats, score, true.genes, false.genes)
  roc.auc <- flux::auc(roc.res$frac_false, roc.res$frac_true)
  prc.res <- prc(stats, score, true.genes, false.genes)
  prc.auc <- flux::auc(prc.res$recall, prc.res$precision)
  return(list("roc"=roc.res,
              "roc.auc"=roc.auc,
              "prc"=prc.res,
              "prc.auc"=prc.auc))
}


#' Load non-rCNV gene scores
#'
#' Load & normalize other (non-rCNV) scores
#'
#' @param meta.in path to gene constraint metadata .tsv
#'
#' @return data.frame of scores
#'
#' @export
load.other.scores <- function(meta.in){
  other.scores <- c("gnomad_pLI", "gnomad_oe_mis_upper", "gnomad_oe_lof_upper",
                    "exac_cnv_z", "rvis_pct", "eds", "hurles_hi")
  meta <- read.table(meta.in, header=T, sep="\t", comment.char="")[, c("gene", other.scores)]
  oeuf.idxs <- grep("_upper", colnames(meta))
  meta[, oeuf.idxs] <- apply(meta[, oeuf.idxs], 2, function(vals){
    vals <- vals - min(vals, na.rm=T)
    vals <- vals / max(vals, na.rm=T)
    vals <- 1 - vals
  })
  meta$exac_cnv_z <- meta$exac_cnv_z - min(meta$exac_cnv_z, na.rm=T)
  meta$exac_cnv_z <- meta$exac_cnv_z / max(meta$exac_cnv_z, na.rm=T)
  meta$rvis_pct <- (100 - meta$rvis_pct) / 100
  meta$eds <- meta$eds - min(meta$eds, na.rm=T)
  meta$eds <- meta$eds / max(meta$eds, na.rm=T)
  return(meta)
}


#' Make gene features more interpretable
#'
#' Modify gene feature matrix to improve interpretability of regression coefficients
#'
#' @param feats data.frame of gene features
#'
#' @return data.frame of modified gene features
#'
#' @export
mod.features <- function(feats){
  # Remove PCA-based features (uninterpretable)
  remove.feats <- colnames(feats)[grep("_component_", colnames(feats), fixed=T)]
  if(length(remove.feats) > 0){
    feats <- feats[, -which(colnames(feats) %in% remove.feats)]
  }

  # Mirror some features where a smaller value = more important
  reverse.feats <- c(colnames(feats)[grep("_oe_", colnames(feats), fixed=T)],
                     "rvis", "rvis_pct")
  feats[, reverse.feats] <- -feats[, reverse.feats]

  # Helper function to return list of highly correlated features (optional)
  get.correlated.feat.pairs <- function(feats, min.cor=0.7){
    feat.names <- colnames(feats)[-1]
    cor.mat <- cor(feats[, -1])
    cor.pairs <- data.frame("feat1"=character(), "feat2"=character(), "r"=numeric())
    for(ridx in 1:nrow(cor.mat)){
      for(cidx in 1:ncol(cor.mat)){
        fname.r <- rownames(cor.mat)[ridx]
        fname.c <- colnames(cor.mat)[cidx]
        cor.stat <- as.numeric(cor.mat[ridx, cidx])
        if(cor.stat >= min.cor &
           fname.r != fname.c &
           cidx > ridx){
          cor.pairs <- rbind(cor.pairs, c(fname.r, fname.c, cor.stat))
        }
      }
    }
    colnames(cor.pairs) <- c("feat1", "feat2", "r")
    return(cor.pairs)
  }

  # Selectively remove highly correlated features
  cor.feats.to.prune <- c("median_expression_q1", "median_expression_q3",
                          "expression_mad_min", "expression_mad_q1",
                          "expression_mad_q3", "expression_mad_max",
                          "expression_mad_sd",
                          intersect(colnames(feats)[grep("chromhmm_", colnames(feats), fixed=T)],
                                    colnames(feats)[grep("_sd", colnames(feats), fixed=T)]),
                          colnames(feats)[grep("gnomad_mu", colnames(feats), fixed=T)],
                          "cen_dist", "tel_dist",
                          "gnomad_oe_mis", "gnomad_oe_lof", "rvis_pct")
  feats <- feats[, which(!colnames(feats) %in% cor.feats.to.prune)]

  return(feats)
}
